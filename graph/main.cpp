#include <iostream>
#include "directedGraph.h"

using namespace std;

int main() {

    directedGraph G;

    G.addVertex("a");
    G.addVertex("b");
    G.addVertex("c");
    G.addVertex("d");
    G.addVertex("e");
    G.addVertex("f");
    G.addVertex("g");
    G.addVertex("h");
    G.addVertex("i");
    G.addVertex("j");

    //step 1:  Implement an "addEdge" method which
    //creates a bidirectional edge connection between two vertices.

    G.addEdge("a", "b");
    G.addEdge("a", "e");
    G.addEdge("b", "e");
    G.addEdge("c", "b");
    G.addEdge("d", "a");
    G.addEdge("d", "c");
    G.addEdge("e", "c");
    G.addEdge("e", "d");
    G.addEdge("f", "d");
    G.addEdge("g", "c");
    G.addEdge("g", "f");
    G.addEdge("h", "c");
    G.addEdge("h", "d");
    G.addEdge("h", "e");
    G.addEdge("i", "h");
    G.addEdge("j", "e");
    G.addEdge("j", "i");

    G.display(); //print each vertex and its neighbors to make sure everything worked

    //step 2: Implement breadth-first search.
    //Test it by implementing a test method that 1) calls a private breadth first search method on a source vertex,
    //then 2) prints to the screen each vertex and it's predecessor computed by breadth first search.
    G.testBreadthFirstSearch("a");

    //step 3: Create a shortest path method
    //Suggested aproach:  first call breadth first search using the first vertex as the source.
    //Next, write a method that follows the predecessor links generated by breadth first search from the destination back to the source,
    //each step concatenating the visited item to an output string.

//    cout << "Shortest path from a to j: " <<  G.shortestPath("a", "j"); << endl; //should list vertices of shortest path from a to j
//    cout << "Shortest path from h to c: " << G.shortestPath("h", "c"); << endl;
//    cout << "Shortest path from j to a: " << G.shortestPath("j", "a"); << endl;


    return 0;
}